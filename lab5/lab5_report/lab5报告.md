# 练习1：加载应用程序并执行（需要编码）

> `do_execv`函数调用`load_icode`（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序。你需要补充`load_icode`的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好`proc_struct`结构中的成员变量`trapframe`中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的`trapframe`内容。
>
> 请在实验报告中简要说明你的设计实现过程。
>
> - 请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

# 练习2：父进程复制自己的内存空间给子进程（需要编码）

> 创建子进程的函数`do_fork`在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过`copy_range`函数（位于kern/mm/pmm.c中）实现的，请补充`copy_range`的实现，确保能够正确执行。

```c
int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end,
               bool share) {
    ...
            /* LAB5:EXERCISE2 YOUR CODE*/
             
            void * kva_src = page2kva(page);
            void * kva_dst = page2kva(npage);
            memcpy(kva_dst, kva_src, PGSIZE);
            ret = page_insert(to, npage, start, perm);
	...
}
```

- `void * kva_src = page2kva(page);`
  - `page2kva`：返回给定 `struct Page` 管理的内存的内核虚拟地址
  - 将源页面 `page` 的物理地址映射到内核的虚拟地址
- `void * kva_dst = page2kva(npage);`
  - 将目标页面 `npage` 的物理地址映射到内核的虚拟地址。得到目标页面在内核虚拟地址空间中的起始地址
- `memcpy(kva_dst, kva_src, PGSIZE);`
  - 将源页面的内容复制到目标页面
- `ret = page_insert(to, npage, start, perm);`
  - `page_insert`：建立一个物理页（`npage`）和一个虚拟地址之间映射
  - 建立目标地址空间 `to` 中目标页面 `npage` 与指定线性地址 `start` 之间的映射关系
  - `start` 是当前复制的线性地址，`perm` 是权限标志，包括用户/内核态、读/写/执行等

在 `copy_range` 函数中的主要步骤包括：

1. 通过 `get_pte` 函数找到进程 A 的某个虚拟地址对应的页表项，并检查是否有效。
2. 如果页表项有效，则为进程 B 分配一个新的物理页（`npage`）。
3. 使用 `page2kva` 函数获取源页和目标页的内核虚拟地址。
4. 使用 `memcpy` 函数将源页的内容复制到目标页中（大小为一个页面大小 `PGSIZE`）。
5. 最后使用 `page_insert` 函数建立进程 B 的线性地址 `start` 和新物理页 `npage` 之间的映射关系。

## 如何设计实现`Copy on Write`机制？给出概要设计，鼓励给出详细设计。

> Copy-on-write（简称COW）的基本概念是指如果有多个使用者对一个资源A（比如内存块）进行读操作，则每个使用者只需获得一个指向同一个资源A的指针，就可以该资源了。若某使用者需要对这个资源A进行写操作，系统会对该资源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源A的“私有”拷贝—资源B，可对资源B进行写操作。该“写操作”使用者对资源B的改变对于其他的使用者而言是不可见的，因为其他使用者看到的还是资源A。

“Copy on Write” 机制的主要思想为使得进程执行 fork 系统调用进行复制的时候，父进程不会简单地将整个内存中的内容复制给子进程，而是暂时共享相同的物理内存页；而当其中—个进程需要对内存进行修改的时候，再额外创建—个自己私有的物理内存页，将共享的内容复制过去，然后在自己的内存页中进行修改

**具体设计：**

1. **页面管理**
   - 每个页面都增加一个计数器（`reference counter`），记录进程共享相同的物理页面的数量
   - 在页表项中，增加一个标志位，用于表示该页面是否是只读的
2. **写时复制**
   - 当一个进程试图写入一个只读页面时，操作系统会进行写时复制
   - 操作系统会检查`reference counter`，如果为1（只有一个进程），那么直接将页面标记为可写。如果大于1，进行页面复制
   - 新的页面分配物理内存，并将原始页面的内容复制到新页面，新页面的`reference counter`设为1，原始页面的`reference counter`减1（当减为0时就会释放物理内存）
3. **页表更新**
   - 更新原始页面的页表项，将其指向新的物理页面
   - 更新新页面的页表项，将其标记为可写

# 练习3： 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）

> 请在实验报告中简要说明你对 fork/exec/wait/exit函数的分析。并回答如下问题：
>
> - 请分析fork/exec/wait/exit的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？
> - 请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）

![](./make_qemu.png)

![](./make_grade.png)

